\chapter{Implementazione}
\label{cap:implementazione}

L'implementazione del PoC è una parte fondamentale del progetto di stage, in quanto permette di verificare la fattibilità del prodotto e di valutare la bontà delle scelte progettuali.\\
In questo capitolo verranno descritte le principali scelte implementative, sia per quanto riguarda il frontend che il backend.\\

\section{Struttura del progetto}
La struttura del progetto è stata organizzata in modo da separare il frontend dal backend, in modo da poterli sviluppare in modo indipendente. Inoltre, è stato scelto di utilizzare una repository su Azure DevOps per il versioning del codice, in modo da poter avere uno storicizzazione delle modifiche.
\section{Backend}
Il backend è stato sviluppato utilizzando il linguaggio di programmazione C\texttt{\#} e il framework ASP.NET Core. 
Come ambiente di sviluppo è stato utilizzato Visual Studio 2022.\\
Il backend è stato sviluppato seguendo il template fornito dall'azienda, che prevede l'utilizzo di un'architettura a layer.\\
\subsection{Architettura a layer}
L'architettura a layer è una tipologia di architettura software che prevede la suddivisione del codice in diversi livelli, ognuno dei quali ha un compito ben preciso, e che comunica con gli altri livelli attraverso le interfacce. Questo permette di avere un codice più modulare e mantenibile, in quanto ogni livello ha un compito ben preciso e non si occupa di altro.\\
Il backend è composto da un unico progetto "AdMaioraStreamingPOC", che contiene i vari layer suddivisi in cartelle, ognuna delle quali contiene le soluzioni relative al layer. I layer sono: API, Core e Data.\\

\subsubsection{API}
Il layer API è il livello più esterno dell'applicazione, e si occupa di gestire le richieste HTTP in arrivo dal frontend. Per fare ciò, utilizza il framework ASP.NET Core, che permette di gestire le richieste HTTP in modo semplice e veloce.
È divisa in due soluzioni: Controller e DTO.\\
\paragraph{Controllers}
I Controllers sono le classi che si occupano di gestire le richieste HTTP in arrivo dal frontend, utilizza il framework ASP.NET Core e la libreria AutoMapper per semplificare la conversione dei DTO in entità e viceversa; inoltre, utilizza la dependency injection per iniettare le dipendenze necessarie dalle classi di Service presenti nel layer Core, l'uso di questa tecnica rende i controller indipendenti dalle implementazioni concrete delle dipendenze, favorendo la separazione delle responsabilità e facilitando la sostituzione o la modifica delle dipendenze senza dover modificare il codice del Controller stesso.\\
Per ogni entità del database è stato creato un controller, che contiene i metodi CRUD e non, per gestire le richieste HTTP in modo completo. Quando un controller riceve una richiesta HTTP, utilizza la dependency injection per iniettare le dipendenze necessarie dalle classi di Service presenti nel layer Core, e poi chiama il metodo corrispondente, restituendo il risultato in formato JSON.\\

\paragraph{DTO}
I DTO sono classi che contengono la struttura dei dati che vengono scambiati tra il frontend e il backend.
Per ogni entità del database sono stati creati tre DTO: uno per la creazione, uno per l'aggiornamento e uno per la visualizzazione, così facendo, si evita di scambiare dati inutili tra frontend e backend, e si evita di dover gestire la serializzazione e deserializzazione di dati inutili. Inoltre, utilizzando i DTO, si evita di dover esporre le entità del database al frontend, favorendo la separazione tra frontend e backend.\\

\subsubsection{Core}
Il layer Core è il livello intermedio dell'applicazione, e si occupa di gestire la logica di business dell'applicazione. È diviso in tre soluzioni: Model e Services.\\

\paragraph{Model}
I Model sono classi che rappresentano le entità nel database, il loro scopo è quello di mappare le entità del database in classi C\texttt{\#}, in modo da poterle utilizzare all'interno della logica del codice. Per ogni entità del database è stato creato un Model, che contiene le proprietà dell'entità.\\

\paragraph{Services}
I Services sono classi che si occupano di gestire la logica di business dell'applicazione, utilizzano i Model per accedere ai dati nel database, e li restituiscono al layer API. Per ogni entità del database è stato creato un Service, che contiene i metodi CRUD e non, per gestire la logica di business dell'applicazione, fornisce i metodi al layer API attraverso interfacce, e a sua volta, vengono iniettate le dipendenze necessarie del Provider presente nel layer Data, delle credenziali per l'accesso ad Azure e della configurazione per il server TUS.io. Il suo scopo principale è quello di fornire un'interfaccia tra il layer API e il layer Data, favorendo la separazione delle responsabilità e facilitando la sostituzione o la modifica delle dipendenze senza dover modificare il codice del Service stesso. Inoltre si occupa anche della comunicazione con i servizi esterni, infatti gestisce l'upload dei video su Azure Media Services, tramite le sue API dedicate; comunica con il servizio TUS.io, che si occupa dell'upload dei video dal frontend al backend, quando un video viene caricato sul server TUS.io, il front end invia una chiamata al backend con l'id TUS del file caricato, viene passato ai metodi del Service, che si occupa di recuperare il file e successivamente di caricarlo su Azure Media Services.\\

\subsubsection{Data}
Il layer Data è il livello più interno dell'applicazione, e si occupa di gestire l'accesso ai dati nel database. È diviso in tre soluzioni: Context, Providers e Entity.\\

\paragraph{Context}
Il Context è la classe che si occupa di gestire l'accesso ai dati nel database, quando viene inizializzato, gli viene iniettata la configurazione per il collegamento al database e definisce tre proprietaria di tipo DbSet, una per ogni entità del database, che consente di effettuare operazione di query e manipolazione dei dati.\\

\paragraph{Providers}
I Providers sono classi che si occupano di gestire l'accesso ai dati nel database, utilizzano il Context per accedere ai dati nel database, e li restituiscono al layer Core convertendoli in Model tramite l'AutoMapper. È stata creata una classe per ogni entità del database, che contiene i metodi CRUD per gestire l'accesso ai dati nel database. Il suo scopo principale è quello di fornire un'interfaccia tra il layer Core e il database, favorendo la separazione delle responsabilità e facilitando la sostituzione o la modifica delle dipendenze senza dover modificare il codice del Provider stesso.\\

\paragraph{Entity}
Le Entity sono classi che rappresentano le entità nel database, il loro scopo è quello di mappare le entità del database in classi C\texttt{\#}, in modo da poterle utilizzare all'interno della logica del codice. Per ogni entità del database è stato creato un Entity, che contiene le proprietà dell'entità. Queste classi sono utilizzate dal Context per accedere ai dati nel database. Oltre a ciò, vengono utilizzate per definire le proprietà delle entità nel database, tramite il framework Entity Framework Core e il suo sistema di migrazioni, ovvero, quando viene modificata una proprietà di un Entity, viene eseguita una migrazione, che modifica la struttura del database in base alle modifiche apportate.\\

\section{Frontend}
Il frontend è stato sviluppato utilizzando il framework React e la libreria grafica Material-UI.\\
È stato utilizzato Visual Studio code come ambiente di sviluppo, e Node.js come runtime per l'esecuzione del codice.\\
Il frontend è diviso in tre cartelle principali: Components, Pages e Services, utilizzando il template fornito dall'azienda che prevede l'utilizzo del template Container-Presenter.\\

\subsection{Architettura}
L'architettura del frontend è divisa in tre cartelle: Pages, Common e Context.

\subsubsection{Pages}
La cartella Pages contiene le pagine dell'applicazione, ovvero, le pagine che vengono visualizzate all'utente. Ogni pagina è divisa a sue volta in tre componenti: Context, Page e Components.\\

\paragraph{Context}
Il Context svolge il ruolo di fornire uno stato condiviso e funzionalità ai componenti figli che ne fanno parte.


\section{Integrazione con Azure Media Services}